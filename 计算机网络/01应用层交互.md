# 01 应用层交互

**应用层常见协议**

> * 超文本传输：HTTP、HTTPS
> * 文件传输：FTP
> * 电子邮件：SMTP、POP3、IMAP
> * 动态主机配置：DHCP
> * 域名系统：DNS



## 1.1 DNS

根据等级不同，域名可以分为

* 顶级域名（Top-level Domain，简称TLD）
* 二级域名
* 三级域名
* ... ...

### 1.1.1 顶级域名分类

* 通用顶级域名（General Top-level Doman，简称gTLD）

> `.com` 公司， `.net` 网络机构， `.org` 组织机构， `.edu` 教育
>
> `.gov` 政府部门， `int` 国际组织，等。

* 国家及地区顶级域名（Country Code Top-level Domain，简称ccTLD）

>`.cn` 中国， `.jp` 日本， `.uk` 英国

* 新通用顶级域名（New gTLD）

> `.vip`，`.xyz`，`.top`，`.club`，`.shop` 等。

**二级域名：**

* 在通用顶级域名之下，一般指域名注册人的名称。如Google和Baidu等。
* 在国家及地区顶级域名下，一般指注册类别，例如com、edu、gov、net等。

### 1.1.2 DNS协议

DNS全称是：Domain Name System，译为：域名系统。利用DNS协议，可以将域名解析称对应的IP地址。

> DNS可以基于UDP，也可以基于TCP，服务器占用53端口

### 1.2.3 DNS服务器

* 客户端首先回访问最近的一台DNS服务器（也就是客户端自己配置的DNS服务器）。
* 所有的DNS服务器都记录了DNS根域名服务器的IP地址。
* 上级DNS服务器记录了下一级DNS服务器的IP地址。
* 全球一共13台IPv4的DNS根域名服务器，25台IPv6的DNS根域名服务器。



## 1.2 DHCP

IP地址的分配方式：

> * 静态IP地址：手动设置。适用于不怎么挪动的台式机、服务器。
> * 动态IP地址：从DHCP服务器自动获取IP地址，适用于移动设备、无线设备。

DHCP（Dynamic Host Configuration Protocol），译为：动态主机配置协议。

> DHCP协议基于UDP，客户端时68端口，服务器时67端口。
>
> DHCP服务器会从IP地址池中，挑选一个IP地址”出租“给客户端一段事件，时间到期就回收它们。

### 1.2.1 DHCP分配IP地址的4个阶段

* DISCOVER：发现服务器

> 发广播包（源IP是0.0.0.0，目标IP是255.255.255.255，目标MAC是FF:FF:FF:FF）。

* OFFER：提供租约

> 服务器返回可以租用的IP地址，以及租用期限、子网掩码、王国、DNS等信息。
>
> 注意：这里有可能会有多个服务器提供租约。

* REQUEST：选择IP地址

> 客户端先择一个OFFER，发送广播包进行回应

* ACKNOWLEDGE：确认

> 被选中的服务器发送ACK数据包给客户端。

DHCP服务器是可以跨网段分配IP地址的，可以借助DHCP中继代理（DHCP Relay Agent）实现跨网段分配IP地址。

> 自动续约：客户端会在租期不足的时候，自动像DHCP服务器发送REQUEST信息申请续约。



## 1.3 HTTP

HTTP（Hyper Text Transfer Protocol），超文本传输协议。

是互联网中应用最广发的应用层协议之一，涉及HTTP最初的目的是提供一种发布和接收HTML页面的方法，由URI来标识具体的资源。

后面用HTTP来传递的数据格式不仅仅是HTML，应用非常广泛。

HTML（Hyper Text Markup Language），超文本标记语言。用于编写网页。

### 1.3.1 HTTP版本

> * 1991年，HTTP/0.9
>
> 只支持GET请求方法获取文本数据（比如HTML文档），且不支持请求头、响应头等，无法向服务器传递太多信息。
>
> * 1996年，HTTP/1.0
>
> 支持POST、HEAD等请求方法，支持请求头、响应头等，支持更多种数据类型。浏览器每次请求都需要与服务器建立一个TCP连接，请求处理完成后立即断开TCP连接。
>
> * 1997年，HTTP/1.1
>
> 支持PUT、DELETE等请求方法，采用持久连接，多个请求可以共用一个TCP连接。
>
> * 2015年，HTTP/2.0。
> * 2018年，HTTP/3.0。



### 1.3.2 HTTP报文格式

* 请求报文

> 方法【空格】URL【空格】版本【回车换行】 //请求行
>
> 首部字段:【空格】值【回车换行】 //首部行
>
> ... ...
>
> 首部字段:【空格】值【回车换行】
>
> 【回车换行】
>
> 实体主体

* 响应报文

> 版本【空格】状态码【空格】短语【回车换行】 //状态行
>
> 首部字段:【空格】值【回车换行】 //首部行
>
> ... ...
>
> 首部字段:【空格】值【回车换行】
>
> 【回车换行】
>
> 实体主体



**ABNF（Augmented BNF）**

* 是BNF（Backus-Naur Form，译为巴科斯-瑙尔范式）的修改、增强版；
* 在RFC 5234文档中表明：ABNF左右Internet中通信协议的定义语言；
* ABNF是最严谨的HTTP报文格式描述形式，脱离ABNF谈论HTTP报文格式，往往都是片面的、不严谨的。

```txt
HTTP-message = start-line
			   *(header-field CRLF)
			   CRLF
			   [message-body]
			   
------------------------------------------
header-field = field-name":" OWS field-value OWS
field-name = token
field-value = *(field-content/obs-fold)
------------------------------------------
message-body = *OCTET  (OCTET指一个字节)
########################################
/	任选一个；
*	0个或多个，2*表示至少2个；
()	组成一个整体；
[]	可有可无的选项。
OWS = *(SP/HTAB)
```

>start-line：开始行，start-line = request-line/status-line；
>
>start-line是内置的CRLF。

请求行：

```txt
# SP = 空格    DIGIT = 数字
# %x48.54.54.50 = HTTP
request-line = method SP request-target SP HTTP-version CRLF
HTTP-version = HTTP-name"/"DIGIT"."DIGIT
HTTP-name = %x48.54.54.50
```



状态行：

```txt
# HTAB = Tab   VCHAR = 字符串
status-line = HTTP-version SP status-code SP reason-phrase CRLF
status-code = 3DIGIT
reason-phrase = *(HTAB/SP/VCHAR/obs-text)
```



### 1.3.3 请求方法

> 8种请求方法：`GET`、`HEAD`、`POST`、`PUT`、`DELETE`、`CONNECT`、`OPTIONS`、`TRACE`;
>
> 额外的1种：`PATCH` 

* GET：常用于读取操作，请求参数直接拼接再URL后面（浏览器对URL长度是有限制的）。
* POST：常用于添加、修改、删除的操作，请求阐述剋放到请求体中（没有长度限制）。
* HEAD：请求得到与GET相同的响应，但是没有响应体。（使用场景，在下载文件前先获取其大小，再决定是否要下载）。
* OPTIONS：用于获取目的资源所支持的通信选项，比如服务器支持的请求方法
* PUT：用于已存在的资源进行整体覆盖（不安全，已经不怎么用了）。
* PATCH：用于对资源进行部分修改（资源不存在，会创建新的资源）。
* DELETE：用于删除指定的资源。
* TRACE：请求服务器回显其收到的请求信息，主要用于HTTP请求的测试或诊断。
* CONNECT：可以开启一个客户端与所请求资源之间的双向沟通的通道，它可以用来创建隧道（tunnel）可以用来访问采用了SSL（HTTPS）协议的站点。



### 1.3.4 头部字段（Header Field）

头部字段可以分为4种类型：

> * 请求头字段（Request Header Fields）：有关要获取资源或客户端本身的消息头。
> * 响应头字段（Response Header Fields）：有关响应的补充信息，比如服务器本身（名称和版本等）的消息头。
> * 实体头字段（Entity Header Fields）：有关实体主题的更多信息，比如主题长度（Content-Length）或其MIME类型。
> * 通用头字段（General Header Fields）：同时适用于请求和响应消息，但与消息主体无关的消息头。



* **请求头字段（Request Header Fields）**

| 头字段          | 说明                                                        |
| --------------- | ----------------------------------------------------------- |
| User-Agent      | 浏览器的身份标识字符串                                      |
| Host            | 服务器的域名、端口号                                        |
| Date            | 发送该消息的日期和时间                                      |
| Referer         | 表示浏览器所访问的前一个页面。（防盗链）                    |
| Content-Type    | 请求体的类型                                                |
| Content-Length  | 请求体的长度（字节为单位）                                  |
| Accept          | 能过接受的响应内容类型（Content-Types）                     |
| Accept-Charset  | 能够接受的字符集                                            |
| Accept-Encoding | 能够接受的编码方式列表                                      |
| Accept-Language | 能够接受的响应内容的自然语言列表                            |
| Range           | 仅请求某一个实体的一部分。字节偏移以0开始（多线程断点下载） |
| Origin          | 发起一个针对跨域资源共享的请求                              |
| Cookie          | 之前由服务器通过Set-Cookie发送过来的Cookie                  |
| Connection      | 该浏览器想要优先使用的连接类型                              |
| Cache-Control   | 用来指定这次请求/响应中的缓存机制指令                       |



* **响应头字段（Response Header Fields）**

| 头字段                      | 说明                                         |
| --------------------------- | -------------------------------------------- |
| Data                        | 发送该消息的日期和时间                       |
| Last-Modified               | 所请求对象的最后修改日期                     |
| Server                      | 服务器的名字                                 |
| Expires                     | 指定一个时间，超过改时间则认为此响应已经过期 |
| Content-Type                | 响应体类型                                   |
| Content-Encoding            | 内容使用的编码类型                           |
| Content-Length              | 响应体的长度                                 |
| Content-Disposition         | 一个可以让客户端下载文件并建议文件名的头部   |
| Accept-Range                | 服务器支持那些种类的部分内容范围             |
| Content-Range               | 这部分消息是属于完整消息的那部分             |
| Access-Control-Allow-Origin | 指定那些网站可参与带跨域支援共享过程中       |
| Location                    | 用来重定向，或者在建立某个新资源时使用       |
| Set-Cookie                  | 返回一个Cookie让客户端去保存                 |
| Connection                  | 针对改连接所预期的选项                       |
| Cache-Control               | 缓存机制告知是否可以缓存该对象，时间单位秒   |





### 1.3.5 状态码

状态码指示HTTP请求是否已经成功完成，状态码可以分为5类：

> * 信息响应：100-199
> * 成功响应：200-299
> * 重定向：300-399
> * 客户端错误：400-499
> * 服务器错误：500-599

常见状态码：

> * **100：continue** （请求的初始部分已经被服务器收到，并且没有被服务器拒绝。客户端应该继续发送剩余的请求，如果请求已经完成，就忽略这个响应）。



> * **200：OK** （请求成功）。



> * **302：Found** （重定向，请求的资源暂时被移动到了由Location头部指定的URL上）。
> * **304：Not Modified** （说明无需再次传输请求的内容，也就是说可以使用缓存的内容）。



> * **400：Bad Request** （由于语法无效（由开发人员设置主动发400），服务器无法理解该请求）。
> * **401：Unauthorized** （由于缺乏目标资源要求的身份验证凭证）。
> * **403：Forbidden** （服务器端由能力处理该请求，但是拒绝授权访问）。
> * **404：Not Found** （服务器端无法找到所请求的资源）。
> * **405：Method Not Allowed** （服务器禁止了使用当前HTTP方法的请求）。
> * **406：Not Acceptable** （服务器端无法提供与Accept-Charset以及Accept-Language指定的值相匹配的响应）。
> * **408：Req Timeout** （服务器想要将没有在使用的连接关闭）。



> * **500：Internal Server Error** （所请求的服务器遇到意外的情况并阻止其执行请求）。
> * **501：Not Implemented** （请求的方法不被服务器支持，因此无法被处理，服务器必须支持的方法GET和HEAD不会返回这个状态码）。
> * **502：Bad Gateway** （作为网关或代理角色的服务器，从上游服务器中收到的响应是无效的）。
> * **503：Service Unavailable** （服务器尚未处于可以接收请求的状态，通常造成这种情况的原因市由于服务器停机维护或者已超载）。



### 1.3.6 表单提交 Form

#### 常用属性

> * **action**：请求的URI。
>
> * **method**：请求的方法（GET、POST）。
>
> * **enctype**：POST请求时，请求体的编码方式（默认值：application/x-www-urlencoded：用&分隔参数，用=分隔键和值，字符用URL编码方式进行编码）。
>
>   （multipart/form-data：适用于复杂的内容提交，请求头会多一个boundary，请求体会被boundary包围，然后分块，文件上传必须使用这种方式。）



## 1.4 跨域 CORS

前后端分离：从形式上来说，就是前端和后端的内容分离出来，作为两个项目分别开发。跨域受同源策略影响，规定默认情况下，AJAX请求只能发送给同源的URL（同源是指三个相同：协议、域名（IP），端口）。

### 跨域资源共享

* 解决AJAX跨域请求的常用方法

> CORS （Cross-Origin Resoure Sharing），跨域资源共享。

* CORS的实现需要客户端和服务端同时支持

> * **客户端**
>
>   所有的浏览器都支持（IE至少IE10版本）。
>
> * **服务端**
>
>   需要返回响应的响应头（比如Access-Control-Allow-Origin）。
>
>   告知浏览器这是一个允许跨域访问的请求。



## 1.5 Cookie 和 Session

* Cookie：在客户端（浏览器）存储一些数据，服务器可以返回Cookie交给客户端去存储，存储到本地磁盘中。
* Session：在服务器存储一些数据，一般存在内存中。

Cookie身份验证过程：

>* 登录成功后，服务器，创建一个Session，存储一个id和用户信息，并通过响应头Set-Cookie：JSEESIONID=xxx发送给客户端；
>
>* 客户端收到响应头的内容后会将Cookie：JSEESIONID=xxx的信息存储起来，Cookie中一般会带有两个字段（domain和path，一般由服务器设置），作用是将来请求那些路径时会携带cookie。
>* 客户端下次直接请求内容页面时，发现Cookie中的domain和path与请求的相同，就会在请求头中携带cookie。
>* 服务器收到请求头后检查cookie，发现携带有会话id，然后去Session匹配，匹配成功后，即通过身份验证。

这种技术常常用于会话跟踪。















