# 继承和派生



在C++中，代码重用是通过 “继承 inheritance” 机制实现的，所谓  “继承” 就是在一个已经存在的类基础上，在建立一个新类。从已有的类派生出新的类，派生类就继承了原有类（基类）的特征，包括成员和方法。

通过继承可以完成一下功能：

1. 可以在已有类的基础上添加新功能，如队于数组类，可以添加数学计算；
2. 可以给类添加数据成员；
3. 可以修改类方法的行为；

继承只需提供新特性，不需要访问源码就可以派生出类。

==**可升级、可维护**==



## 继承

```c++
//格式
class Child : public Father {
    //....
}
```

派生类对象储存基类的数据成员，派生类对象可以使用基类的==非私有==函数，继承了基类的接口；派生类需要自己的构造函数；可以根据需要添加额外的数据成员的函数。

子类不能直接调用父类私有成员，在子类中可以再次实现父类方法，从而覆盖父类实现。



* 内存问题

> 没有继承时。成员变量和成员函数会分开存储：
>
> ​	1、对象内存中只包含成员变量，存储在栈区或堆区（new）
>
> ​	2、成员函数与对象内存分离，存储在代码区
>
> 有继承关系时，派生类的内存模型可以看成是基类成员变量和新增成员变量的总和；所有成员函数仍然存储在看另一个区域——代码区，又由所有对象共享。



* 基类与子类关系

> 基类指针用new生成一个子类对象，则调用的为基类的构造函数和其他方法；如果一个基类引用指向一个子类对象则，通过该引用无法使用子类特有的方法。父类引用/指针（已经指向了一个子类对象）需要强转成子类引用或指针。



| 基类成员\继承方式 | 公有继承 | 私有继承 | 保护继承 |
| :---------------: | :------: | :------: | :------: |
|     `public`      |   公有   |   私有   |  受保护  |
|    `protected`    |  受保护  |   私有   |  受保护  |
|     `private`     | 不被继承 | 不被继承 | 不被继承 |

注：这里的不被继承指在子类中无法访问，但在内存中是真实地存在。



## 继承与组合

继承是 is-a 的关系，组合是 has-a 的关系。



## 多态与虚函数

多态是一种代码重用的方法。多态是指参数的多态。



* 面向对象编程的多态性包括：

> 不同对象可以调用同一个函数；
>
> 不同的对象调用时会产生不同的行为；



重载：函数名相同，参数不同，与返回值无关。（静态多态，编译多态 ：速度快但是缺乏灵活性）除此外还有函数模板等。

动态多态——函数重写

要实现C++函数重写，必须要先把父类的成员函数设定为虚函数；

```c++
//格式 在父类的方法前加关键字 virtual
virtual void func();

//子类中
void func() override;
```

当传递父类的子类型时，参数可以自动转换，当B是A的子类型时（class B  : public A），就意味着所有对A的操作都可以对B对象进行操作，即B重用A的操作来实现自己的操作。

1. 向上 转型时安全的
2. 向上转型是自动完成的
3. 向上转型时会丢失子类信息

向下转型时不安全的，因为不知道类型，编译时可能不会报错但执行时会出现逻辑错误。



## 虚函数其他知识点

1. 构造函数不能是虚函数；
2. 析构函数应该是虚函数（除非不用做基类，通常应该为基类提供一个虚析构函数，即时它不需要析构函数）；
3. 友元不能是虚函数（因为友元不是类成员）；



* 纯虚函数

```c++
virtual 返回类型 函数名(参数表) const = 0;
//这个形式是纯虚函数，让基类没有函数体
//纯虚函数只有函数名，没有函数体在基类中不能被调用
//纯虚函数要求必须有派生类来实现纯虚函数体的功能
```

==抽象类只能被继承不能实例化！！！==

