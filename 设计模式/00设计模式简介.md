# 0 设计模式简介

## 什么是设计模式
简单来说，设计模式就是解决不断重复问题的方案。其精髓在于增加代码的复用性。当然这里的复用性是指编译层面的复用性，不是简单的复制粘贴。对于机器而言每当源文件发生"改变"，在整体编译的时候就会从新编一发生改变的文件。而设计模式要做的就是减少和避免改变的发生，更多的是扩展。

设计模式更多的是注重问题的解决方案，而非具体的实现方法和编程语言。

## 设计模式的核心思想
设计模式的核心思想就是用面向对象的设计方式实现松耦合的、结构化的高复用的问题解决方案。要正确的理解"隔离变化"正确处理 责任问题，反映在各个层次上具体体现为：

* 语言：对象封装了代码和数据；
* 规格：对象是一系列可悲使用的公共接口；
* 概念：对象是某种拥有责任的抽象。

设计模式不是为了设计而设计，我们在使用设计模式的时候不要为了使用而使用，而是要通过重构来获得模式，简单说就是我们要先让代码跑起来，再去做优化，我们要在优化中寻找合适的模式来解决问题，而不是先决定使用什么模式然后在生搬硬套，当然在熟练之后可以直接使用合适的模式。而在重构获得模式的过程中一般要遵守以下八个原则：

* 一、依赖倒置原则（DIP）

> 1. 高层（稳定）模块不应该依赖于低层（变化）二者都应该依赖于抽象。
> 2. 抽象（稳定）不应该依赖于具体实现细节（变化），实现的细节应该依赖于抽象。
> 简单来说就是应该抽象出基本的结构和组织方式，而具体的实现都应该依赖抽象的内容而互相关联，单独修改任意一个具体实现都不会影响到其他具体实现，从而实现解绑定松耦合。

举一个例子，如果有一个窗口类，能够在窗口中显示各种形状，这里我们设计两个形状类：长方形、圆形。如果我们直接在窗口类中使用这两个形状类，不仅所有的绘图细节操作要窗口类进行实现，而且一但产生新的形状或者老的形状要有修改，就会增加大量工作去修改窗口类和其他类的内容，这就是典型的紧耦合，窗口类应该是一个稳定的高层模块是不希望经常发生变动的，而各种形状的类是低层类是不稳定的，但是高层类却依赖于低层类，责任划给了高层。

所以这里我们可以抽象出一个抽象类，形状类，在窗口类中直接调用形状类，而其他具体的形状类通过继承抽象形状类，并各自实现各自需要的方法，在窗口类调用其他具体形状类时就会通过各自实现的方法处理各自的形状，从而实现了"依赖倒置"，也通过抽象的形状类将窗口类与具体的形状类进行隔离实现了解耦合。如果需要添加形状只需要新建类并且继承抽象类即可，且修改老形状时也不需要再关心窗口类了。

* 二、开放封闭原则

> 1. 对扩展开放，对更改封闭。
> 2. 类模块应该是可扩展的，但不是可修改的。

同样还是刚才的例子，我们更改后的模式，每个具体实现都是依赖于抽象类，而抽象类时不需要修改也不能修改的。对于高层模块也就是窗口类，不会再因为具体的形状类的增加或减少而修改，也就实现了对更改封闭。而当我们有新的需求，需要增加具体形状的时候我们只需要新建类然后继承抽象基类然后再实现就可以，不需要再关注高层模块，这就是对扩展开放。

* 三、单一责任原则（SRP）

> 1. 一个类应该仅有一个引起它变化的原因（这里不是变化的行为）。
> 2. 变化的方向隐含着类的责任。

这里（我理解的也不够深刻）应该指的是我们的类应该尽量简单，功能专一，因为越专一说明依赖范围越小，耦合程度越低。

* 四、Liskov 替换原则

> 1. 子类必须能够替换他们的基类。
> 2. 继承表达了类型的抽象。

还是上面的例子，每个具体的形状类都继承自形状抽象类，每个具体形状都能替代形状，也就是 "长方形是形状" "圆形是形状" 这是一种 "Is-a" 的关系，而不是 "Have-a" 的关系。同样 "长方形是形状" "圆形是形状" 也是一种抽象，这些...都是"形状"他们有着共同的特性。

* 五、接口隔离原则

> 1. 不应该强迫客户程序依赖它们不用的方法。
> 2. 接口应该小而完备。

第一条应该不用说明，第二条指的是我们要在满足功能和需求的基础上尽量减少接口的开放量，尽量将方法都私有化，只将需要的接口开放，这样就在一定程度上保证了代码内部的封闭性，也一定程度的支持了第一条。

* 六、优先使用对象组合而不是继承（继承是类属关系）

> 1. 类继承通常为白箱复用，对象组合通常为黑箱复用。
> 2. 继承在某种程度上破坏了封装性，子类父类耦合度高。
> 3. 对象组合只要求有良好定义的外部接口。


* 七、封装变化点

> 1. 使用封装来创建对象之间的分界层，让设计者可以在封装的一侧进行修改，而不会对另一侧产生不良影响。


* 八、针对接口编程，而不是针对实现编程

> 1. 不将变量类型声明成某个具体的类型，而是声明成某个接口。
> 2. 客户程序无需知道具体的类型，只需要知道对应的接口。
> 3. 高内聚、松耦合。



## 常见的设计模式

目前我们常见的设计模式主要有23种，如下：

1. Abstract Factory（抽象工厂）
2. Adapter（适配器）
3. Bridge（桥接）
4. Builder（生成器）
5. Chain of Responsiblity（职责链）
6. Command（命令）
7. Composite（组合）
8. Decorator（装饰）
9. Facade（外观）
10. Factory Method（工厂方法）
11. Flyweight（享元）
12. Interpreter（解释器）
13. Iterator（迭代器）
14. Meditator（中介者）
15. Memento（备忘录）
16. Observer（观察者）
17. Prototype（原型）
18. Proxy（代理）
19. Singleton（单件）
20. State（状态）
21. Strategy（策略）
22. Template Method（模版方法）
23. Visitor（访问者）


下面通过以下两个角度对这些方法进行分类：

通过「**目的**」分类：

* 创建型模式

> Abstract Factory（抽象工厂）
> 
> Builder（生成器）
> 
> Factory Method（工厂方法）
> 
> Prototype（原型）
> 
> Singleton（单件）

* 结构模式

> Adapter（适配器）
> 
> Bridge（桥接）
> 
> Composite（组合）
> 
> Decorator（装饰）
> 
> Facade（外观）
> 
> Flyweight（享元）
> 
> Proxy（代理）


* 行为模式

> Chain of Responsiblity（职责链）
> 
> Command（命令）
> 
> Interpreter（解释器）
> 
> Iterator（迭代器）
> 
> Meditator（中介者）
> 
> Memento（备忘录）
> 
> Observer（观察者）
> 
> State（状态）
> 
> Strategy（策略）
> 
> Template Method（模版方法）
> 
> Visitor（访问者）


通过「**封装变化**」分类：

* 组件协作

> Template Method（模版方法）
> 
> Strategy（策略）
> 
> Observer（观察者）

* 单一职责

> Decorator（装饰）
> 
> Builder（生成器）

* 对象创建

> Factory Method（工厂方法）
> 
> Abstract Factory（抽象工厂）
> 
> Prototype（原型）
> 
> Builder（生成器）


* 对象性能

> Singleton（单件）
> 
> Flyweight（享元）


* 接口隔离

> Facade（外观）
> 
> Proxy（代理）
> 
> Meditator（中介者）
> 
> Adapter（适配器）


* 状态变化

> Memento（备忘录）
> 
> State（状态）


* 数据结构

> Composite（组合）
> 
> Iterator（迭代器）
> 
> Chain of Responsiblity（职责链）


* 行为变化

> Command（命令）
> 
> Visitor（访问者）


* 领域问题

> Interpreter（解释器）














