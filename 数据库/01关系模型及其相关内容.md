# 01 关系模型及其相关内容

## 关系模型简述

形象的说，一个关系就是一个Table。关系模型就是处理Table的，它由三个部分组成：

> * 描述DB各种数据基本结构形式Table/Relation
> * 描述Table与Table之间所可能发生的各种操作（关系运算）
> * 描述这些操作所应遵循的约束条件（完整性约束）

关系模型的三个要素：

> * 基本结构：Relation/Table
> * 基本操作：关系运算（**基本的**：并、差、积、选择、投影；**扩展的**：交、连接、除。）
> * 完整性约束：实体完整性、参照完整性和用户自定义完整性。

关系模型一般以集合为单位操作，非关系模型一般以记录为单位操作。

**关系的定义**：

表（Table）：

> * 首先定义“列”的取值范围是“域”。
> * 再定义行“元组”及所有可能组合成的元组：笛卡尔积（每个列的取值的组合）。

关系：一组域的笛卡尔积的子集（有意义组合的子集）。笛卡尔积中具有某一方面意义的那些元组被称作一个关系（Relation）。由于关系的不同列可能来自同一个域，为区分，需要为每一列起一个属性名。

关系的特性：

> * 列是同质的：即每一列中的分量来自同一个域，是统一类型的数据。
> * 不同的列可来自同一个域，称其中每一列为一个属性，不同的属性要给予不同的属性名。
> * 列位置互换性：区分那一列是靠列名。
> * 行位置互换性：区分哪一行是靠某一或某几列的值（关键字/键字/码字）。

理论上，关系的任意两个元组不能完全相同（数学定义上的规范）；现实应用中，表（Table）可能存在两个完全相同的元组。

**关系第一范式**：属性不可再分（不允许复合属性和多值属性）；

**候选码/候选键**：关系中的一个属性组，其值能够唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选码。

**主码/主键**：当有多个候选码时，可以选定一个作为主码。

**主属性与非主属性**：

> * 包含在任何一个候选码中的属性被称作为主属性，而其他属性被称作非主属性。
> * 最简单的，候选码只包含一个属性。
> * 最极端的，所有属性构成这个关系的候选码，称为全码。

**外码/外键**：

> * 关系R中的一个属性组，他不是R的候选码，但是它是另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。
> * 两个关系通常是靠外码连接起来的。



## 关系模型中的完整性

### 实体完整性

* 关系的主码中的属性值不能为空值；
* 空值：不知道或无意义的值。

### 参照完整性

* 外码可以为空值；
* 若非空值，则其值必须是另一个关系中主码的值，即保证连接的正确性。

### 用户自定义完整性

* 用户针对具体的应用环境定义的完整性约束条件。



## 关系模型中的关系代数

### 关系代数运算的特点

> 基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积（广义积）、选择、投影和更名等基本操作。
>
> 以及交、连接和关系除等扩展操作，是一种集合思维的操作语言。
>
> 关系代数操作以一个或多个关系位输入，结果是一个新的关系。
>
> 用对关系的运算来表达查询，需要指明所用操作，具有一定的过程性。
>
> 是一种抽象语言，是学习其他数据库语言，如SQL等的基础。

关系代数操作：**集合操作**和**纯关系操作**

>* 集合操作：并、交、差、笛卡尔积。
>* 纯关系操作：投影、选择、连接、除。

### 关系代数的基本操作

#### 并相容性

定义：参与运算的两个关系及其相关属性之间有一定的相对性、可比性或意义关联性。

> 关系R和关系S存在相容，当且仅当：
>
> * 关系R和关系S的属性数目必须相同；
> * 对于任意i，关系R的第i个属性的域必须和关系S的第i个属性的域相同。

#### 并（Union）

定义：假设关系R和关系S是相容的，则关系R与关系S的并运算结果也是一个关系，它是由或者出现在关系R中，或者出现在S中的元组构成。并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。

#### 差（Difference）

定义：假设关系R和关系S是相容的，则关系R与关系S的差运算结果也是一个关系，它是由或者出现在关系R中但是不出现在S中的元组构成。差运算是不满足交换律的。

#### 广义笛卡尔积（Cartesian Product）

定义：关系R与关系S的广义笛卡尔积运算的结果也是一个关系，它是由关系R中的元组与关系S的元组进行所有可能的拼接（或串接）构成。两个关系元组的组合。

#### 选择（Select）

定义：给定一个关系R，同时给定一个选择的条件condition（简记con），选择运算结果也是一个关系，它从关系R中选择除满足给定条件condition的元组构成。

> 选择操作从给定的关系中选出满足条件的行。
>
> 注意条件符号的运算优先级。

#### 投影（Project）

定义：给定一个关系R，投影运算结果是一个关系，它从关系R中选出属性包含在A中的列构成。

### 关系代数的扩展操作

#### 交（Intersection）

定义：假设关系R和关系S是并相容的，则关系R与关系S的交运算结果也是一个关系，它由同时出现在关系R和关系S中的元组构成。

#### 连接（Join）

* $\Theta$ - 连接（$\Theta$ - Join）

投影与选择操作只是对单个关系（表）进行操作，而实际应用中往往涉及多个表之间的操作，这就需要$\Theta$ - 连接操作。

定义：给定关系R和关系S，R与S的$\theta$连接运算结果也是一个关系，它由关系R和关系S的笛卡尔积中，选取R中属性A与S中属性B之间满足$\theta$条件的元组组成。这里要求属性A和属性B具有可比性，其中$\theta$为比较条件。

* 等值连接（Equi-Join）

定义：给定关系R和关系S，R与S的等值连接运算结果也是一个关系，它由关系R和关系S的笛卡尔积中，选取R中属性A与S中属性B上值相等的元组所构成。即当$\Theta$ - 连接中的规则为“=”时，就为等值连接。

* 自然连接（Natural-Join）

定义：给定关系R和关系S，R与S的自然连接运算结果也是一个关系，它由关系R和关系S的笛卡尔积中，选取R同属性组B上值相等的元组所构成。其本质上一种特殊的等值连接，连接后去除一组重复的属性。

* 外连接（Outer-Join）

定义：两个关系R与S进行连接时如果R（或S）中的元组在S（或R）中早不到相匹配的元组，则为避免该元组信息丢失，从而将该元组与S（或R）中假定存在的全为空值的元组形成连接，放置在结果关系中，这种连接称之为外连接（Outer-Join）。

> 外连接=自然连接（或$\theta$连接）+=失配的元组（与空元组形成的连接）。
>
> 外连接的形式：左外连接、右外连接、全外连接：
>
> * 左外连接=自然连接（或$\theta$连接）+=左侧表中失配的元组。
> * 右外连接=自然连接（或$\theta$连接）+=右侧表中失配的元组。
> * 全外连接=自然连接（或$\theta$连接）+=两侧表中失配的元组。

#### 更名

即将表的表名更改，通常使用在自连接操作中。

#### 除（Division）

除法运算经常用于求解 “**查询...全部的/所有的...**” 问题。

前提条件：给定关系R为n度关系与关系S为m度关系的除运算，当且仅当：S属性集是R属性集的真子集时，关系R才能与关系S进行除法运算，其运算结果也是一个关系，其结果分为两部分如下：

> * 属性：属性为关系R的属性去除关系S的属性。
> * 值：所得结果的关系与关系S的笛卡尔积的所有元组必须都能在关系R中找到。



## 关系演算

关系演算是以数理逻辑中的谓词演算为基础的。

关系演算是描述关系运算的一种思维方式。

SQL语言是继承了关系代数和关系演算各自的优点所形成的。

按照谓词变量（操作对象）不同，可分为关系元组演算和关系域演算。

### 关系元组演算

基本形式：$$\{t|P(t)\}$$ ，上式表示：所有使谓词P为真的元组t的集合。

> * t是元组变量；
> * t $\in$ R表示元组t在关系R中；
> * t[A]表示元组t的分量，即t在属性A上的值；
> * P是谓词逻辑相似的公式，P(t)表示以元组t为变量的公式

P(t)可以如下递归地进行定义：

* 三种原子公式是公式

> (1) $s\in R$ ;
>
> (2) $s[A]\;\theta\; c$ ;
>
> (3) $s[A]\;\theta\; u[B]$ 。

* 如果P是公式，那么 $\lnot P$ 也是公式。
* 如果 $P_1,P_2$ 是公式，则 $P_1\and P_2,P_1\or P_2$ 也是公式。
* 如果P(t)是公式，R是关系，则 $\exists(t\in R)(P(t))$ 和 $\forall(t\in R)(P(t))$也是公式

元组演算公式与关系代数对比应用例子：

题目：

> 已知：学生关系：Student(S#, Sname, Sage, Ssex, Sclass)
>
> ​	课程关系：Course(C#, Cname, Chours, Credit, Tname)
>
> ​	选课关系：SC(S#, C#, Score)

（1）求学过李明老师讲授所有课程地学生姓名（全都学过）

$$\pi_{Sname}(\pi_{Sname,C\#}(S \Join SC \Join C) \div \pi_{C\#}(\sigma_{Tname="李明"}(C)))$$

$$\{t[Sname]|t\in S\;\forall (u\in C\and u[Tname]="李明")(\exists(w\in SC)(w[S\#] = t[S\#]\and w[C\#] = t[C\#])) \}$$

（2）求没学过李明老师讲授任意一课程地学生姓名（全没学过）

$$\pi_{Sname}-\pi_{Sname}(\sigma_{Tname="李明"}(S\Join SC\Join C))$$

$$\{t[Sname]|t\in S\and\;\forall(u\in C\and u[Tname]="李明")(\lnot\exists(w\in SC)(w[S\#] = t[S\#]\and w[C\#] = t[C\#])) \}$$

（3）求至少学过一门李明老师讲授课程地学生姓名（至少学过一门）

$$\pi_{Sname}(\sigma_{Tname="李明"}(S\Join SC\Join C))$$

$$\{t[Sname]|t\in S\and\exists(u\in SC)\exists(w\in C) (u[Tname]="李明"\and w[S\#]=t[S\#]\and w[C\#]=u[C\#]) \}$$

（4）求至少有一门李明老师坚守课程没有学过的学生姓名（至少有一门没学过）

$$\pi_{Sname}-\pi_{Sname}(\pi_{Sname,C\#}(S \Join SC \Join C) \div \pi_{C\#}(\sigma_{Tname="李明"}(C)))$$

$$\{t[Sname]|t\in S\;\exists  (u\in C\and u[Tname]="李明")(\lnot\exists(w\in SC)(w[S\#] = t[S\#]\and w[C\#] = t[C\#])) \}$$

### 关系域演算

公式基本形式：$\{<x_1,x_2,...,x_n>|P(x_1,x_2,...,x_n)\}$ 其中，$x_i$ 代表域变量或常量，$P$ 为以 $x_i$ 为变量的公式。

P(t)可以如下递归地进行定义：

* 三种原子公式是公式

> (1) $<x_1,x_2,...,x_n>\in R$，由域变量构成的元组属于关系R ;
>
> (2) $x\;\theta\; c$ ，域变量x与常量c之间满足比较关系 $\theta$;
>
> (3) $x\;\theta\; y$ ，域变量x与域变量y之间满足比较关系 $\theta$。

* 如果P是公式，那么 $\lnot P$ 也是公式。
* 如果 $P_1,P_2$ 是公式，则 $P_1\and P_2,P_1\or P_2$ 也是公式。
* 如果P(t)是公式，x是域变量，则 $\exists(x)(P(x))$ 和 $\forall(x)(P(x))$也是公式

#### 域演算语言QBE

> QBE：Query By Example
>
> 特点：操作独特，基于屏幕表格的查询语言，不用书写复杂公式，只需要将条件填在表格中即可。是一种高度非过程化的查询语言。

QBE操作框架由四个部分构成

> 关系名区：用于书写待查询的关系名。
>
> 属性名区：用于显示对应欢喜名区关系的所有属性名。
>
> 操作命令区：用于书写查询操作的命令。
>
> 查询条件区：用于书写查询条件。

### 关系演算的安全性

不产生无限关系和无穷验证的运算被称为是安全的。

> * 关系代数是一种集合运算，是安全的。（集合本身是有限的，有限元素集合的有限次运算仍旧是有限的。）
> * 关系演算不一定是安全的。（例如：$\{t|\lnot(R(t))\}\;,\{t|R(t)\or t[2]>3 \}$ 可能表示无限关系，R(t) 是有限的，但是不在 R(t) 中的袁术就可能使无限的，后例中的 t[2]>3 是无限的。再例如验证可能导致无限验证。

所以需要对关系演算世家约束条件，即任何公式都在一个集合范围内操作，而不是无限范围内操作，才能保证其安全性。

* 安全约束有限集合DOM

$DOM(\psi)$ 是一个有限集合，其中的每个符号要么是 $\psi$ 中明显出现的符号，要么是出现在 $\psi$ 中的某个关系R的某个元组的分量。DOM主要用于约束 $\psi$ 中一些谓词的计算范围，它不必是最小集合。











