# 哈希函数

[TOC]

## 1 哈希函数的定义及使用方法

### 1.1 定义

> Hash，一般翻译做散列、杂凑，或音译为哈希，是把任意长度的输入 $M$（又叫做预映射pre-image）通过散列算法变换成固定长度的输出 $H(M)$ ，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。
>
> Hash算法可以将一个数据转换为一个标志，这个标志和源数据的每一个字节都有十分紧密的关系。因此改变消息中的任何一位或几位比特值，哈希码都会发生改变。Hash算法还具有一个特点，就是很难找到逆向规律。



### 1.2 使用方式

>哈希函数用来提供消息认证的基本使用方式，共以下6种：
>
>（1）消息与哈希码链接后用单密钥加密。用于确定消息未被篡改，同时提供保密性。
>
>（2）用单密钥加密算法仅对哈希码加密。在不要求保密的情况下可减少处理负担。
>
>（3）用公钥加密算法和发送方的密钥仅加密哈希码。数字签名。
>
>（4）消息的哈希值用公钥加密算法和发送方的密钥加密后与消息链接，再对链接后的结果采用单密钥加密算法。提供了保密性和数字签名。
>
>（5）通信双方共享一个保密值 $S$ ，A计算消息 $M$ 和密钥值 $S$ 链接在一起的哈希值，并将此哈希值附加到 $M$ 后发往B。仅提供认证。
>
>（6）在（5）的方法中消息与哈希值链接以后再增加单密钥加密运算，从而提供保密性。



### 1.3 哈希函数应满足的条件

> 哈希函数的目的是为需认证的数据产生一个“指纹”。为了能够实现对数据的认证，哈希函数应满足以下性质：
>
> （1）函数的输入可以是任意长度。
>
> （2）函数的输出是固定长度。
>
> （3）已知 $x$ ，求$H(x)$ 较为容易，可用硬件或软件实现。
>
> （4）已知 $h$ ，求使得 $H(x)=h$ 的 $x$ 在计算上是不可行的，这一性质称为函数的单向性，称 $H(x)$ 为单向哈希函数。
>
> （5）已知 $x$ ，找出 $y(y\neq x)$ 使得 $H(y)\neq H(x)$ 在计算上是不可行的。如果单向哈希函数也满足这一性质，则称其为弱单向哈希函数。
>
> （6）找出任意两个不同输入 $x,y$ ，使得 $H(x)=H(y)$ 在计算上是不可能的。如果单向哈希函数也满足这一性质，则称其为强单向哈希函数。
>
> 性质（5）（6）给出了哈希函数无碰撞性的概念，如果焊锡函数对不同的输入可产生先通的输出，则称该函数具有碰撞性。



## 2 生日攻击

### 2.1 相关问题

#### Ⅰ类生日攻击

> 定义：已知 $H(x)$ 求 $k$ 个输入，至少有一个输入 $y$ ，使得 $H(x)=H(y)$ 的概率大于0.5。寻找 $y$ 的攻击成为Ⅰ类生日攻击。

#### Ⅱ类生日攻击

> 定义：寻找 $H$ 函数的 $k$ 个输入中至少有两个相同输出的概率大于0.5。寻找相同输出的两个输入的攻击方式称为Ⅱ类生日攻击。



### 2.2 生日攻击的概率问题

已知一个哈希函数 $H$ 有 $n$ 个可能的输出（$m$ 位bit输出，$n=2^m$），尝试从 $k$ 个不同的输入中，满足Ⅰ类或Ⅱ类攻击的概率要求。概率记为 $P(n,k)$

#### Ⅰ类攻击概率

$$P_Ⅰ(n,k)=1-{[1-\frac{1}{n}]}^k\approx 1-{[1-\frac{k}{n}]}=k/n$$  ，其中当 $|x|\ll1$ 时有 ${(1+x)}^k\approx  (1+kx)$ 。

若 $P_Ⅰ(n,k)=0.5$ ，$n=2^m$ ，则 $k=2^{m-1}$ 。

#### Ⅱ类攻击概率

$$P_Ⅱ(n,k)=1-\frac{n!}{(n-k)!\:n^k}$$ ，令 $P_Ⅱ(n,k)>0.5$ ，可得 $k\approx 1.18\sqrt{n}\approx\sqrt{n}$ 。当 $n$ 取 $n=365$ 时，$k=1.18\sqrt{365}=22.54$ ，故在23个人中就有0.5的概率能找到两个生日相同的人，这概率比我们想象的要打的多，故又称为生日悖论。



## 3 迭代型哈希函数的一般结构

目前使用的大多数哈希函数如MD5、SHA，其结构都是迭代型的。其中函数的输入M被分为L个分组 $Y_0,Y_1,\ldots,Y_{L-1}$ ,每一个分组长度为 $b$ 比特，若最后一个分组长度不够，需对其做填充。最后一个分组还包含整个函数的输入长度值，这样一来使得敌手的攻击更为困难。

算法中重复使用一个压缩函数 $f$ ，$f$ 的输入有两项，一项是上一轮（第 $i-1$ 轮）输出的 $n$ 比特值 ${CV}_{i-1}$ ，称为链接变量，另一个输入式在本轮参与计算的 $b$ 比特分组 $Y_{i-1}$ 。$f$ 的输出为 $n$ 比特值 ${CV}_{i}$  。算法开始前需对链变量指定一个初始值 $IV$ ，最后一轮输出的链变量 ${CV}_L$ 即为最终的哈希值。

> 算法如下：
>
> ${CV}_0=VI\qquad(n\:bite)$ ；
>
> ${CV}_i=f({CV}_{i-1},Y_{i-1})\qquad 1\leq i\leq L$ ；
>
> $H(M)={CV}_L$ ；

算法的核心技术是设计无碰撞的压缩函数 $f$ ，由于 $f$ 是压缩函数，其碰撞时不可避免的，因此设计上要保证找出其碰撞在计算上是不可行的。